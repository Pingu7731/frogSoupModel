import 'dart:async';

import 'package:build/build.dart';
import 'package:glob/glob.dart';

class TypeRegistryBuilder extends Builder {
  @override
  Map<String, List<String>> get buildExtensions => {
    r'$lib$': ['frogsoup_type_registry.g.dart'],
  };

  @override
  FutureOr<void> build(BuildStep buildStep) async {
    // Find all .pb.dart files in the models directory
    final pbFiles = await buildStep
        .findAssets(Glob('lib/models/**/*.pb.dart'))
        .toList();

    // Sort files to ensure consistent output
    pbFiles.sort();

    // Generate instance lines for each protobuf class
    final instanceLines = <String>[];
    for (final asset in pbFiles) {
      final library = await buildStep.resolver.libraryFor(asset);

      final protoClasses = library.classes.where(
        (e) =>
            e.allSupertypes.any(
              (t) => t.getDisplayString() == 'GeneratedMessage',
            ) ==
            true,
      );

      for (final protoClass in protoClasses) {
        instanceLines.add('  ${protoClass.name}.getDefault(),');
      }
    }

    final output =
        '''
// This file is automatically generated. Do not edit manually.
// Generated by TypeRegistryBuilder

import 'package:frogsoup_model/frogsoup_model_exports.dart';
import 'package:protobuf/protobuf.dart';

final frogsoupTypeRegistry = TypeRegistry([
${instanceLines.join('\n')}
]);
    ''';

    await buildStep.writeAsString(
      AssetId(buildStep.inputId.package, 'lib/frogsoup_type_registry.g.dart'),
      output,
    );
  }
}

Builder typeRegistryBuilder(BuilderOptions options) => TypeRegistryBuilder();
